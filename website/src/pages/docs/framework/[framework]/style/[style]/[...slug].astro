---
import type { SupportedFramework, SupportedStyle } from '@/types/docs';
import type { CollectionEntry } from 'astro:content';

import { getCollection, render } from 'astro:content';

import DocsLayout from '@/layouts/Docs.astro';
import { ALL_FRAMEWORK_STYLE_COMBINATIONS } from '@/types/docs';
import { filterSidebar, getAllGuideSlugs } from '@/utils/docs/sidebar';
import defaultMarkdownComponents from '@/components/typography/defaultMarkdownComponents';
import { TableOfContents } from '@/components/docs/TableOfContents';
import H3 from '@/components/typography/H3.astro';

export async function getStaticPaths() {
  const docsCollection = await getCollection('docs');

  /**
   * Build a map of allowed slugs for each framework/style combination.
   * Only docs that appear in the filtered sidebar will be allowed to generate pages.
   */
  type AllowedSlugsMap = Map<string, Set<string>>;
  const allowedSlugsMap: AllowedSlugsMap = new Map();

  for (const { framework, style, key } of ALL_FRAMEWORK_STYLE_COMBINATIONS) {
    const sidebarForFrameworkAndStyle = filterSidebar(framework, style);
    const slugsForFrameworkAndStyle = getAllGuideSlugs(sidebarForFrameworkAndStyle);
    allowedSlugsMap.set(key, new Set(slugsForFrameworkAndStyle));
  }

  // Generate a path for each doc that's visible in at least one framework/style combination
  const staticPaths = ALL_FRAMEWORK_STYLE_COMBINATIONS.flatMap(({ framework, style, key }) => {
    const allowedSlugs = allowedSlugsMap.get(key)!;

    // Filter docs to only those visible in this combination's sidebar
    return docsCollection
      .filter((doc) => allowedSlugs.has(doc.id))
      .map((doc) => ({
        params: {
          framework,
          style,
          slug: doc.id,
        },
        props: { doc },
      }));
  });

  return staticPaths;
}

type Props<F extends SupportedFramework = SupportedFramework> = {
  doc: CollectionEntry<'docs'>;
  framework: F;
  style: SupportedStyle<F>;
};

const { framework, style, slug } = Astro.params;
const { doc } = Astro.props;
const { Content, headings, remarkPluginFrontmatter } = await render(doc);

// Use conditional headings from our remark plugin if available, otherwise fallback to default headings
const conditionalHeadings = remarkPluginFrontmatter?.conditionalHeadings;
const filteredHeadings = conditionalHeadings
  ? conditionalHeadings.filter((h: any) => {
      const matchesFramework = !h.frameworks || h.frameworks.includes(framework);
      const matchesStyle = !h.styles || h.styles.includes(style);
      return matchesFramework && matchesStyle;
    })
  : headings;
---

<DocsLayout doc={doc} framework={framework} style={style} slug={slug}>
  <main
    class:list={[
      'grid grid-cols-1 xl:grid-cols-(--xl-grid-cols)',
      '[grid-template-areas:var(--grid-template-areas)] xl:[grid-template-areas:var(--xl-grid-template-areas)]',
      '[--scroll-mt:var(--mobile-toc-h)] xl:[--scroll-mt:0px]',
    ]}
    style="
      --xl-grid-cols: minmax(0, 1fr) calc(var(--spacing) * 59);
      grid-template-rows: auto minmax(0, 1fr);
      --grid-template-areas: 'toc' 'article';
      --xl-grid-template-areas: 'article toc';
      --mobile-toc-h: calc(var(--spacing) * 15);
    "
  >
    <div
      class="sticky overflow-y-auto z-40"
      style="grid-area: toc; top: var(--nav-h); max-height: calc(100vh - var(--nav-h));"
    >
      <TableOfContents client:idle headings={filteredHeadings} />
    </div>
    <article class="@container px-6 pb-12 lg:px-12" style="grid-area: article;">
      <header class="border-b border-light-40 max-w-3xl mx-auto py-8 mb-8">
        <H3 as="h1" class="mt-0 mb-2">{doc.data.title}</H3>
        <p class="@lg:font-medium">{doc.data.description}</p>
      </header>
      <Content components={{ ...defaultMarkdownComponents }} />
    </article>
  </main>
</DocsLayout>
