import { glob } from 'glob';
import postcss from 'postcss';
import tailwindcss from 'tailwindcss';
import { ASTParser, extractComponentName } from './ast-parser.js';
import { semanticCSSGenerator } from './semantic-css-generator.js';
import { semanticTransform } from './semantic-transform.js';
import { multiFormatOutput } from './multi-format-output.js';
import { ClassUsage, CompilerConfig, ParsedFile } from './types.js';

export class TailwindCSSCompiler {
  private parser = new ASTParser();
  private config: CompilerConfig;

  constructor(config: CompilerConfig) {
    this.config = config;
  }

  /**
   * Run the complete compilation process
   */
  async compile(): Promise<void> {
    console.log('üöÄ Starting Tailwind CSS compilation...');

    // Step 1: Parse source files and extract className usage
    const parsedFiles = await this.parseSourceFiles();
    const allUsages = parsedFiles.flatMap(file => file.usages);

    console.log(`üìÑ Parsed ${parsedFiles.length} files`);
    console.log(`üéØ Found ${allUsages.length} className usages`);

    if (allUsages.length === 0) {
      console.log('‚ö†Ô∏è  No className usages found. Skipping CSS generation.');
      return;
    }

    // Step 2: Generate vanilla CSS if requested
    if (this.config.generateVanilla) {
      await this.generateCSS(allUsages, parsedFiles, false);
    }

    // Step 3: Generate CSS modules if requested
    if (this.config.generateModules) {
      await this.generateCSS(allUsages, parsedFiles, true);
    }

    console.log('‚úÖ Compilation complete!');
  }

  /**
   * Parse all source files and extract className usages
   */
  private async parseSourceFiles(): Promise<ParsedFile[]> {
    const files = await this.findSourceFiles();
    const parsedFiles: ParsedFile[] = [];

    for (const file of files) {
      try {
        const parsed = this.parser.parseFile(file);
        if (parsed.usages.length > 0) {
          parsedFiles.push(parsed);
          console.log(`  üìù ${file}: ${parsed.usages.length} usages`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è  Failed to parse ${file}:`, error);
      }
    }

    return parsedFiles;
  }

  /**
   * Find all source files based on patterns
   */
  private async findSourceFiles(): Promise<string[]> {
    const allFiles: string[] = [];

    for (const pattern of this.config.sources) {
      const files = await glob(pattern);
      allFiles.push(...files);
    }

    // Remove duplicates
    return [...new Set(allFiles)];
  }

  /**
   * Generate CSS using PostCSS pipeline
   */
  private async generateCSS(usages: ClassUsage[], parsedFiles: ParsedFile[], isModule: boolean): Promise<void> {
    const format = isModule ? 'CSS Modules' : 'Vanilla CSS';
    console.log(`üé® Generating ${format}...`);

    // Generate appropriate filename based on source files
    const { vanillaFilename, modulesFilename } = this.generateFilenames(parsedFiles);

    // Create initial CSS input (empty, will be populated by plugins)
    const inputCSS = '/* Generated by semantic CSS generator */';

    // Configure PostCSS pipeline
    const processor = postcss([
      // Step 1: Generate intermediate CSS with @apply directives
      semanticCSSGenerator({
        usages,
        mappings: this.config.mappings || [],
        generateVanilla: !isModule,
        generateModules: isModule
      }),

      // Step 2: Process @apply directives with Tailwind
      tailwindcss(this.config.tailwindConfig ? require(require.resolve(this.config.tailwindConfig, { paths: [process.cwd()] })) : {}),

      // Step 3: Transform selectors and add enhancements
      semanticTransform({
        isModule,
        componentMappings: isModule ? {} : this.getComponentMappings(),
        elementMappings: isModule ? {} : this.getElementMappings()
      }),

      // Step 4: Output files
      multiFormatOutput({
        outputDir: this.config.outputDir,
        generateVanilla: !isModule,
        generateModules: isModule,
        vanillaFilename,
        modulesFilename
      })
    ]);

    try {
      await processor.process(inputCSS, { from: undefined });
    } catch (error) {
      console.error(`‚ùå Error generating ${format}:`, error);
      throw error;
    }
  }

  /**
   * Generate appropriate filenames based on source files
   */
  private generateFilenames(parsedFiles: ParsedFile[]): { vanillaFilename: string; modulesFilename: string } {
    if (parsedFiles.length === 1) {
      // Single component: use component name from file path
      const componentName = extractComponentName(parsedFiles[0].path);
      const kebabComponentName = this.toKebabCase(componentName);
      return {
        vanillaFilename: `${kebabComponentName}.css`,
        modulesFilename: `${componentName}.module.css`
      };
    } else if (parsedFiles.length > 1) {
      // Multiple components: use generic naming
      return {
        vanillaFilename: 'media-chrome-vanilla.css',
        modulesFilename: 'media-chrome-modules.css'
      };
    } else {
      // No files (shouldn't happen): fallback to generic
      return {
        vanillaFilename: 'vanilla.css',
        modulesFilename: 'modules.css'
      };
    }
  }

  /**
   * Convert PascalCase to kebab-case
   */
  private toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .toLowerCase();
  }

  /**
   * Get component-specific selector mappings
   */
  private getComponentMappings(): Record<string, string> {
    return {
      'PlayButton': 'media-play-button',
      'MuteButton': 'media-mute-button',
      'FullscreenButton': 'media-fullscreen-button',
      'VolumeRange': 'media-volume-range',
      'TimeRange': 'media-time-range',
      'CurrentTimeDisplay': 'media-current-time-display',
      'DurationDisplay': 'media-duration-display',
      'MediaContainer': 'media-container'
    };
  }

  /**
   * Get element-specific selector mappings
   */
  private getElementMappings(): Record<string, string> {
    return {
      '.button': '.control-button',
      '.icon': '.icon',
      '.display': '.time-display',
      '.range': '.range-control'
    };
  }

}