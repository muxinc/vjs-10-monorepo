import postcss from 'postcss';
import tailwindcss from '@tailwindcss/postcss';

import type { ClassUsage, SemanticMapping } from './types.js';
import { ASTParser } from './ast-parser.js';
import { semanticCSSGenerator } from './semantic-css-generator.js';
import { semanticTransform } from './semantic-transform.js';

/**
 * Options for compilation output
 */
export interface CompilationOutput {
  /** Vanilla CSS output (if generated) */
  vanilla?: string;
  /** CSS Modules output (if generated) */
  modules?: string;
  /** Statistics about the compilation */
  stats: {
    usageCount: number;
    vanillaGenerated: boolean;
    modulesGenerated: boolean;
  };
}

/**
 * Options for the core compilation functions
 */
export interface CoreCompilerOptions {
  /** Custom semantic mappings */
  mappings?: SemanticMapping[];
  /** Whether to generate vanilla CSS */
  generateVanilla?: boolean;
  /** Whether to generate CSS modules */
  generateModules?: boolean;
  /** Component-specific selector mappings for vanilla CSS */
  componentMappings?: Record<string, string>;
  /** Element-specific selector mappings for vanilla CSS */
  elementMappings?: Record<string, string>;
}

/**
 * Pure function that compiles from source file string to CSS output
 *
 * @param sourceCode - TypeScript/JavaScript source code as string
 * @param filename - Optional filename for context (used in error reporting)
 * @param options - Compilation options
 * @returns CompilationOutput with CSS strings and stats
 */
export async function compileFromString(
  sourceCode: string,
  filename: string = 'input.tsx',
  options: CoreCompilerOptions = {}
): Promise<CompilationOutput> {
  const parser = new ASTParser();

  // Parse the source code to extract usages
  const usages = parser.parseString(sourceCode, filename);

  // Delegate to the usages-based compiler
  return compileFromUsages(usages, options);
}

/**
 * Pure function that compiles from extracted usages to CSS output
 *
 * @param usages - Array of className usages extracted from AST parsing
 * @param options - Compilation options
 * @returns CompilationOutput with CSS strings and stats
 */
export async function compileFromUsages(
  usages: ClassUsage[],
  options: CoreCompilerOptions = {}
): Promise<CompilationOutput> {
  const {
    mappings = [],
    generateVanilla = true,
    generateModules = true,
    componentMappings = getDefaultComponentMappings(),
    elementMappings = getDefaultElementMappings(),
  } = options;

  if (usages.length === 0) {
    return {
      stats: {
        usageCount: 0,
        vanillaGenerated: false,
        modulesGenerated: false,
      },
    };
  }

  const output: CompilationOutput = {
    stats: {
      usageCount: usages.length,
      vanillaGenerated: false,
      modulesGenerated: false,
    },
  };

  // Generate vanilla CSS if requested
  if (generateVanilla) {
    output.vanilla = await generateCSS(usages, {
      mappings,
      isModule: false,
      componentMappings,
      elementMappings,
    });
    output.stats.vanillaGenerated = true;
  }

  // Generate CSS modules if requested
  if (generateModules) {
    output.modules = await generateCSS(usages, {
      mappings,
      isModule: true,
      componentMappings: {},
      elementMappings: {},
    });
    output.stats.modulesGenerated = true;
  }

  return output;
}

/**
 * Internal helper to generate CSS using PostCSS pipeline
 */
async function generateCSS(
  usages: ClassUsage[],
  options: {
    mappings: SemanticMapping[];
    isModule: boolean;
    componentMappings: Record<string, string>;
    elementMappings: Record<string, string>;
  }
): Promise<string> {
  const { mappings, isModule, componentMappings, elementMappings } = options;

  // Create initial CSS input (empty, will be populated by plugins)
  const inputCSS = `/* Generated CSS - ${isModule ? 'CSS Modules' : 'Vanilla CSS'} */\n/* This file is auto-generated by @vjs-10/tailwind-css-compiler */\n/* Do not edit manually - changes will be overwritten */\n\n`;

  // Configure PostCSS pipeline
  const processor = postcss([
    // Step 1: Generate intermediate CSS with @apply directives
    semanticCSSGenerator({
      usages,
      mappings,
      generateVanilla: !isModule,
      generateModules: isModule,
    }),

    // Step 2: Process @apply directives with Tailwind
    tailwindcss(),

    // Step 3: Transform selectors and add enhancements
    semanticTransform({
      isModule,
      componentMappings,
      elementMappings,
    }),
  ]);

  const result = await processor.process(inputCSS, { from: undefined });
  return result.css;
}

/**
 * Default component mappings for vanilla CSS
 */
function getDefaultComponentMappings(): Record<string, string> {
  return {
    PlayButton: 'media-play-button',
    MuteButton: 'media-mute-button',
    FullscreenButton: 'media-fullscreen-button',
    VolumeRange: 'media-volume-range',
    TimeRange: 'media-time-range',
    CurrentTimeDisplay: 'media-current-time-display',
    DurationDisplay: 'media-duration-display',
    MediaContainer: 'media-container',
  };
}

/**
 * Default element mappings for vanilla CSS
 */
function getDefaultElementMappings(): Record<string, string> {
  return {
    '.button': '.control-button',
    '.icon': '.icon',
    '.display': '.time-display',
    '.range': '.range-control',
  };
}