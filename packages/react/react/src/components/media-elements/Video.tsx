// NOTE: This is just a thin wrapper around the "skeletal" connected component that also applies a default (but overridable) definition of the
// "BaseComponent" that defines the actual UI.
// NOTE: Definitions like this should be able to be autogenerated via codegen, defined via a factory function (HoC or higher order component), or both.
// import BaseComponent from '../ui/PlayerUI';
import * as React from 'react';
import {
  DetailedHTMLProps,
  ElementType,
  Ref,
  useImperativeHandle,
  useRef,
  VideoHTMLAttributes,
} from 'react';
/** @TODO Improve types crud (CJP) */
import ConnectedComponent from '../connected/Video';
import { createMediaStateOwner } from '@vjs-10/media';

// These are the first steps/WIP POC of decoupling the Media State Owner from the DOM.
// Note that everything will still work if you use:
// 1. an audio/video element directly
// 2. a custom element a la media-elements
type CreateMediaStateOwner = typeof createMediaStateOwner;
const useMediaStateOwner = (
  ref: Ref<any>,
  createMediaStateOwner: CreateMediaStateOwner /*, props? */
) => {
  const mediaStateOwnerRef = useRef(createMediaStateOwner(/* props? */));
  useImperativeHandle(ref, () => mediaStateOwnerRef.current, []);
  /** @TODO Parameterize this (CJP) */
  type ComponentProps = DetailedHTMLProps<
    VideoHTMLAttributes<HTMLVideoElement>,
    HTMLVideoElement
  >;
  return {
    updateMediaElement(
      mediaEl: HTMLMediaElement | null,
      props: ComponentProps
    ) {
      // NOTE: The details here will almost definitely change for a less "bare bones"/"POC" implementation of Media State Owner impl. (CJP)
      mediaStateOwnerRef.current.mediaElement = mediaEl ?? undefined;
      mediaStateOwnerRef.current.src = props.src as string;
      if (props.muted) {
        mediaStateOwnerRef.current.muted = props.muted;
      }
    },
  };
};

const BaseComponent: ElementType<
  Omit<
    DetailedHTMLProps<VideoHTMLAttributes<HTMLVideoElement>, HTMLVideoElement>,
    'ref'
  > & { ref: Ref<any> }
> = ({ children, ref, ...props }) => {
  const { updateMediaElement } = useMediaStateOwner(ref, createMediaStateOwner);
  return (
    <video {...props} ref={(mediaEl) => {
        /** @TODO In later iterations/non-POC, we should be able to have a function that can be used directly for the `ref` prop (CJP) */
        updateMediaElement(mediaEl, props);
      }}>
      {children}
    </video>
  );
};

// NOTE: Assuming FC or "functional component" here for type expediency (though may be fine for our use cases).
type ConnectedComponentProps = Parameters<typeof ConnectedComponent>[0];
type ConnectedComponentReturnType = ReturnType<typeof ConnectedComponent>;
type DefaultedProps = 'component';
type ConnectedComponentWithDefaults = (
  props: Omit<ConnectedComponentProps, DefaultedProps> &
    Partial<Pick<ConnectedComponentProps, DefaultedProps>>,
) => ConnectedComponentReturnType;

const Component: ConnectedComponentWithDefaults = ({
  component = BaseComponent,
  children,
  ...props
}) => {
  return (
    <ConnectedComponent {...props} component={component}>
      {children}
    </ConnectedComponent>
  );
};

export default Component;